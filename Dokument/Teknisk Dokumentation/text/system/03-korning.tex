\subsection{Körning}
\label{sec:systembeskrivning:korning}

Huvudloopen körs åtminstonde 10 gånger i sekunden. Den beräknar var bilen
befinner sig, hur snabbt bilen ska köra, justerar \texttt{car.constant} och sätter det
nya gaspådraget till banan.

Majoriteten av förändringarna i structen \texttt{car} görs i funktionen \texttt{do\_car()}. 
I \texttt{do\_car()} beräknas  först positionen (\texttt{car.position}), 
sedan motsvarande hastighetsparameter (\texttt{car.v}) och därefter det gaspådrag 
(\texttt{car.u}) som ska sättas till banan.

\subsubsection{Position}
\label{sec:system:korning:position}
Det finns två fall när positionen ska beräknas. När en givare har passerats och
när en givare inte har passerats. Under första varvet hanteras endast det första fallet
och från varv 2 och frammåt görs båda paralellt. 

Om en ny givare har passerats, \texttt{car.new\_check\_point == true}, ökar
programmet nuvarande segment (\texttt{car.segment}) med 1. \texttt{car.segment}, som
alltid ligger mellan 1 och 9, används som index för att välja position i en
lista (\texttt{car.pos\_at}). 

Om ingen givare har passerars och bilen har avslutat första varvet, alltså
oftast, görs lite mer avancerade beräkningar. För att beräkna positionen
använder proggrammet först en funktion \texttt{get\_aprox\_v}. Denna utgår ifrån
förra varvets segmentstider (\texttt{car.seg\_times}) och segmentslängder
(\texttt{car.seg\_len}) och beräknar med $v = \frac{s}{t}$ medelhastigheten för nuvarnade
segment, men förra varvet. Denna antas vara ungefär samma sak som nuvarande
hastiget. 

Sedan beräknas den fakiska positionen, i meter från målgivaren, med funktionen
\texttt{get\_position}. Den använder den ungefärliga hastigheten beräknad av
\texttt{aprox\_v} och tiden sedan denna beräkning gjordes senast (en programcykel)
och beräknar med $s = v \cdot t$ den sträcka som bilen har åkt. Sedan adderas denna
med förra kända postionen och retuneras i \texttt{car.position}. 

\subsubsection{Gaspådrag}

Efter positionsberäkningen beräknas det gaspådrag som skall sättas till banan. Detta görs i två
funktioner, \texttt{get\_new\_v} och \texttt{get\_new\_u}.
 
I \texttt{get\_new\_v} används bilens nuvarande postition (\texttt{car.postition})
och hastihetskartan (\texttt{car.map}). I \texttt{car.map} finns en
hastighetsparameter för varje \texttt{car.position}, denna retuneras av funktionen
och sparas i \texttt{car.v}.
 
I \texttt{get\_new\_u} används denna hastighetsparameter tillsammans med
\texttt{car.constant}. Dessa multipliceras och deras produkt retuneras och sparas
i \texttt{car.u}.

\subsubsection{Governor}
\label{sec:systembeskrivning:governor}
Om bootstrap är avslutad, körs den del av koden vars ända uppgift är att 
anpassa \texttt{car.constant}. 

Detta görs med funktionen \texttt{do\_gov}.  Först görs en uppskattning av 
varvtiden utifrån hur lång tid varvet har tagit än
så länge, se REFERENS!. Om bilen är inne på sitt första varv görs uppskattningen endast
utifrån förra segmentet \texttt{car.forcasts\_naive} och om första varvet är
avslutat använder den i stället \texttt{car.forcasts} som kollar på hela varvtiden
fram till och med nu. Detta görs efter segment 4 och 8. Desutom används den
faktiska varvtiden när bilen passerar mål (från varv 2 och frammåt).
 
Sedan jämförs denna uppskattade varvtid med referenstiden (\texttt{car.ref\_time}) 
och \texttt{car.constant} justeras.
\begin{verbatim}
car.constant = car.constant + (status - 1) * 0.08;
\end{verbatim}
Där \texttt{status} är den uppskattade varvtidens förhållande till \texttt{car.ref\_time}.
D.v.s om de är exakt lika blir \texttt{status~ =~ 1}, om uppskattningen är högre blir
den större än 1 och om den är lägre blir den mindre än 1. Således kommer \texttt{car.constant}
höjas eller sänkas proportionellt mot hur långt ifrån \texttt{car.ref\_time} uppskattningen
av varvtiden ligger. 

\subsubsection{Cykel}
\label{sec:system:korning:cykel}
För att verifiera att givarna läses av minst tio gånger i sekunden så körs det
en funktion i slutet av varje cykel som tillfälligt pausar givarnas avläsning.
Funktionen gör en paus på 0.001 sekunder och gör det tills funktionen totalt har
pausat i över 0.07 sekunder. Under körningen så sparar funktionen den högst
uppmätta paustiden.