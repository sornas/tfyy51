 \documentclass[10pt,oneside,swedish]{lips-no_customer}

%\usepackage[square]{natbib}\bibliographystyle{plainnat}\setcitestyle{numbers}
\usepackage[round]{natbib}\bibliographystyle{plainnat}
\usepackage{parskip}

% Configure the document
\title{Teknisk dokumentation}
\author{Yc4}
\date{\today}
\version{0.1}

\reviewed{}{}
\approved{}{}

\projecttitle{Styrning och optimering av bilbana}

\groupname{Yc4}
\groupemail{team\_yc4@liuonline.onmicrosoft.com}
\groupwww{https://www.fs.isy.liu.se/Edu/Courses/TFYY51/}

\coursecode{TFYY51}
\coursename{Ingenjörsprojekt}

\orderer{Erik Frisk, Linköpings universitet}
\ordererphone{+46(0)13-285714}
\ordereremail{ordere@liu.se}

%\customer{Kund, Företag X}
%\customerphone{+46 xxxxxx}
%\customeremail{erik.frisk@liu.se}

\courseresponsible{Urban Forsberg}
\courseresponsiblephone{+46(0)13-281350}
\courseresponsibleemail{urban.frsberg@liu.se}

\supervisor{Viktor Leek}
\supervisorphone{+46(0)13-284493}
\supervisoremail{viktor.leek@liu.se}

\smalllogo{logo} % Page header logo, filename
\biglogo{logo} % Front page logo, filename

\cfoot{\thepage}
\begin{document}
\maketitle

\cleardoublepage
\makeprojectid

\begin{center}
  \Large Projektdeltagare
\end{center}
\begin{center}
  \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Namn} & \textbf{Ansvar} & \textbf{E-post}\\
    \hline
  \end{tabular}
\end{center}

\section*{Dokumenthistorik}
\begin{tabular}{p{.06\textwidth}|p{.1\textwidth}|p{.45\textwidth}|p{.13\textwidth}|p{.13\textwidth}} 
  \multicolumn{1}{c}{\bfseries Version} & 
  \multicolumn{1}{|c}{\bfseries Datum} & 
  \multicolumn{1}{|c}{\bfseries Utförda förändringar} & 
  \multicolumn{1}{|c}{\bfseries Utförda av} & 
  \multicolumn{1}{|c}{\bfseries Granskad}\\
  \hline
  \hline
  0.1 & 2019-11-30 & Första utkast & Alla & \\
  \hline
\end{tabular}

\cleardoublepage
\pagenumbering{arabic}\cfoot{\thepage}
\input{text/00-sammanfattning}

\cleardoublepage
\tableofcontents
\cleardoublepage

\section{Inledning}
\subsection{Bakgrund}
Detta projektet har utförts med hjälp av en bilbana samt flera bilar, givare, spänningsaggregat och en dator inkopplad till givarna på banan. Via datorn har spänning tillförts till bilbanan. Med hjälp av givarna är det möjligt att veta när en bil har passerat en givare. Programvaran utvecklas i Matlab, vilket ligger till grund för styrning av bilarna. 
\subsection{Syfte och mål}
Syftet med projektet var att konstruera ett system som skulle få bilar att automatiskt köra runt en bilbana.
%(Se figur~\ref{fig:track_modell}).
Med hjälp av informationen som har kunnat läsas av från givarna så skulle det
skapas ett system som skulle få bilar med olika egenskaper att köra runt på de två olika 
banorna på en vald referenstid. Huvudmålet är indelat i flera olika krav.
Se avsnitt 3.2 i kravspecifikationen.
\section{Begrepp och systemöversikt}
\section{Systembeskrivning}

\subsection{Innan start}

Vid uppstart ritas knappar ut på displayenm se figur x. Med dessa knappar går
det att välja om en eller två banor ska vara aktiva och om de ska styras
autonomt av systemet eller manuellt med handkontroll. Det går också att ställa
in en referenstid mellan 12 och 15 sekunder med 0,5 sekunders intervall genom
att trycka på + och - på displayen. Varje 0,x sekunder skickas ett kommando till
displayen som skickar information om alla knapptryck som skett sedan minnet
efterfrågades senast. Händelserna bearbetas i den kronologiska ordning de
trycktes i och ändrar på variabler enligt de knapptryck som skett.

\subsection{Uppstart} 

Vid automatisk körning körs funktionen \emph{do\_boot} vars syfte är att få fram en
initierande konstant (\emph{car\_constant}) och spänningspådrag för den bil som står på banan. Då bilen är
positionerad framför målbågen höjer funktionen konstanten kontinuerligt i ett
tidsintervall på 0.7 sekunder. När väl konstanten är tillräckligt stor för att
bilen ska kunna rulla och passera målbågen så dämpas höjningen av konstanten och förändringen sker med en lägre frekvens. Vid passering av den andra givaren så slutar
funktionen tillfälligt att förändra konstanten och låter bilen, med den
tilldelade konstanten, åka igenom det tredje segmentet för att få en uträknad tid. Med
tiden det tagit för bilen att ta sig igenom segmentet räknar funktionen ut
vilken förväntad varvtid bilen skulle få med just den konstanten den hade i
segmentet. (beskriva forecastsuträkningen?) Det sista funktionen gör är att
återigen justera konstanten. Om den förväntade varvtiden är större än 15
sekunder, som är referensvarvtiden för första varvet, så ökar konstanten och är
den förväntade varvtiden mindre än 15 sekunder så sänks konstanten. 

\subsection{Körning}

Huvudloopen körs åtminstonde 10 gånger i sekunden. Den beräknar först var bilen
befinner sig, sedan väljer den hur snabbt bilen ska köra och slutligen sätts den
hastigheten till banan.

Den viktigaste delen av huvudloopen är funktionen \emph{do\_car}. Funktionen
beräknar de ändrinar som skall göras i matlab-structen \emph{car} och är indelad
i många delar.

\subsubsection{Position}

Det finns två fall när positionen ska beräknas. När en givare har passerats och
när en givare inte har passerats. Under första varvet görs endast det första och
från varv 2 och frammåt görs båda paralellt. 

Om en ny givare har passerats, \emph{car.new\_check\_point == true}, ökar
programmet nuvarande segment (\emph{car.segment}) med 1. \emph{car.segment}, som
alltid ligger mellan 1 och 9, används som index för att välja position i en
lista (\emph{car.pos\_at}). 

Om ingen givare har passerars och bilen har avslutat första varvet, alltså
oftast, görs lite mer avancerade beräkningar. För att beräkna positionen
använder proggrammet först en funktion \emph{get\_aprox\_v}. Denna utgår ifrån
förra varvets segmentstider (\emph{car.seg\_times}) och segmentslängder
(\emph{car.seg\_len}) och beräknar med v = s/t medelhastigheten för nuvarnade
segment, men förra varvet. Denna antas vara ungefär samma sak som nuvarande
hastiget. 

Sedan beräknas den fakiska positionen, i meter från målgivaren, med funktionen
\emph{get\_position}. Den använder den ungefärliga hastigheten beräknad av
\emph{aprox\_v} och tiden sedan denna beräkning gjordes senast (en programcykel)
och beräknar med s = v * t den sträcka som bilen har åkt. Sedan adderas denna
med förra kända postionen och retuneras i \emph{car.position}. 

\subsection{Gaspådrag}

Sedan beräknas det gaspådrag som skall sättas till banan. Detta görs i två
funktioner, \emph{get\_new\_v}) och \emph{get\_new\_u}.
 
I \emph{get\_new\_v} används bilens nuvarande postition (\emph{car.postition})
och hastihetskartan (\emph{car.map}). I \emph{car.map} finns en
hastighetsparameter för varje \emph{car.position}, denna retuneras av funktionen
och sparas i \emph{car.v}.
 
I \emph{get\_new\_u} används denna hastighetsparameter tillsammans med
\emph{car.constant}. Dessa multipliceras och deras produkt retuneras och sparas
i \emph{car.u}.

\subsubsection{Governor}

Sedan, om bootstrap är avslutad, körs den del av koden vars ända uppgift är att 
anpassa \emph{car.constant}. 

Detta görs med funktionen \emph{do\_gov}.  Först görs en uppskattning av varvtiden utifrån hur lång tid varvet har tagit än
så länge. Om bilen är inne på sitt första varv görs uppskattningen endast
utifrån förra segmentet \emph{car.forcasts\_naive} och om första varvet är
avslutat använder den i stället \emph{car.forcasts} som kollar på hela varvtiden
fram till och med nu. Detta görs efter segment 4 och 8. Desutom används den
faktiska varvtiden när bilen passerar mål (från varv 2 och frammåt).
 
Sedan jämförs den uppskattade varvtiden med referenstiden \emph{car.ref\_time}.
Om den uppskattade varviden är högre än referenstiden höjs \emph{car.constant}
och om den är lägre sänks \emph{car.constant}.

\subsubsection{Display}

I varje programcykel skickas nuvarande värdet på u till två stapeldiagram på
displayen för vardera bil. Se appendix N för mer information om displayens
stapeldiagram. Om ett nytt varv har inletts skrivs dessutom varvnumret och
varvtiden ut på displayen.

\subsection{Avslut}

När körningen avslutas så får banan ingen mer spänning och bilarna stannar.
Ifall en bil har kört fler än 2 varv så sparas statistik från körningen. 

\section{Händelser}

\subsection{Avslutning av körning}

För att avbryta programmet manuellt kan användaren när som helst trycka på s
eller q på datorns tangentbord. Trycker användaren på q avslutas programmet
direkt. Trycker användaren på s stoppas varje bil var för sig när de är 80 cm
från målgivaren och programmet avslutas när båda bilarna står stilla.

Om det har gått mer än nio sekunder sedan en givare passerades pausas programmet
och användaren informeras på styrdatorn att en bil misstänkts ha fastnat eller
åkt av banan. 

Vid programslut visas statistik om varvtid och genomsnittlig segmenttid på
displayen. Se figurer xx-xx.

\subsection{Missade givare}

Programmet gör redan en uppskattning av bilens position (\emph{get\_position})
 och justerar denna vid ny givare (lägg till referens här).
Eftersom \emph{get\_new\_v} utgår ifrån denna uppskattning, kommer ingen
anpassning behöva göras ifall en givare inte ger utslag. Däremot måste det 
kompenseras nästa gång en givare detekteras. Detta görs med funktionen 
\emph{choose\_position}. Den funktionen jämför positionen beräknad av 
\emph{get\_position} och positionen vald av nuvarande givare. 

Vid varje givare kollar \emph{choose\_position} vilken givare som 
\emph{get\_position} ligger närmast. Funktionen beräknar skillnaden mellan denna
och den givare som valdes med givardetektionen. Denna kallas \emph{seg\_plus}.
I normala fall är \emph{seg\_plus} = 0 (ingen 
missad givare) eller 1 (en missad givare), men den kan också bli högre. Eftersom
programmet inte ska behöva hantera för många givarsignaler ska \emph{seg\_plus}
aldrig kunna bli lägre än 0. Om så ändå är fallet ändras denna till 0. \emph{seg\_plus} 
retuneras av funktionen och används sedan för att höja \emph{car.segment} så att
programmet har koll på var bilen är.

Dessutom behöver den insamlade datan justeras när en eller flera givare har 
missats. Annars kommer \emph{car.seg\_times} spara tiden för flera segment som 
om det vore ett enda. Lösningen är att skriva över denna tid med 0. Alla 
funktioner som använder denna data behöver kolla ifall den är noll eller inte, 
om den är noll används den ifrån varvet innan i stället. Om den också är noll 
används den från två varv tidigare osv.

\section{Programslut}

display\_post\_race\_graphs(seg\_times1, seg\_times2, lap\_times1, lap\_times2,
ref\_time) hanterar knapptryck för att byta mellan de två vyerna. Varje 0,4
sekunder skickas ett kommando till displayen som kopierar det interna minnet
till minnet som delas med styrdatorn. Minnet som delas med styrdatorn läses av
och eventuella knapptryck hanteras genom anrop till antingen
draw\_lap\_graph(...) eller draw\_segment\_graph(...).

draw\_lap\_graph(lap\_times1, lap\_times2, ref\_time) ritar varvtider för
ena bilen i taget och skriver ut medelvärde och standardavvikelse, se figur xx.

Hur mycket ska jag skriva om implementationen här?

draw\_segment\_graph(seg\_times1, seg\_times2)

Samma fråga här som raden ovanför.


\bibliography{references}

\cleardoublepage
\appendix
\section{Handhavande}
Proceduren till handhavande för Matlab:

Starta Matlab 2015b. Observera att användaren måste använda datorn som finns
inne i bilbanerummet och som är inkopplade till bilbanan. Väl inne i Matlab
öppna filvägen för hårdisk X: och hitta sökvägen till yc4\_2019.

Därefter markera och högerklicka på mappen kod och där kommer ett alternativ som
heter Add To Path. Välj sedan Select Folders And Subfolders som dyker upp när
musen pekar på Add To Path. Därefter expandera bilbana mappen följt av yc4
mappen. Öppna sedan main.m och starta systemet genom att klicka på Run i Editorn
i Matlab.

När koden körs i Matlab är dags att starta bilarna detta görs genom att via den
externa touch displayen. Där finns möjligheterna att välja antalet banor som ska
köras samt möjligheten att justera referenstiden. Kryssa även i om någon av
banorna ska köras manuellt. Därefter starta genom att trycka på knappen nere i
det högra hörnet på displayen.

När programmet ska avslutas klickar användaren i kommentar fönstret i Matlab och
klickar på q om bilen ska stanna direkt. Om användaren istället vill att
bilen/bilarna ska stanna precis innan målgivaren klickar användaren på s
(observera att detta fungerar endast efter varv ett).

När programmet avslutas finns möjligheterna att se varvtiden/varvtiderna,
segmentstiden/segmentstiderna samt att avsluta. Detta väljs utifrån de tre
knapparna längst ner på displayen. Dessa knappar är Varv för att se varvtid,
Segment för att se segmentstider. Samt knappen Avsluta.

Om knappen Varv väljs kommer information såsom “target” vilket är vald varvtid.
“Mean” som är genomsnittlig varvtid och “Stdev” är standardavvikelsen. För att
se varvtiden för den andra banan klicka på knappen uppe i högra hörnet.

Om programmet kraschar: Om programmet kraschar öppna main.m. Därefter skriv in
ctrl och enter i avgränsningen som heter "\%\% END OF RACE" som finns i slutet av
koden main.m.

\section{Funktioner och filer}

\subsection{System}

choose\_position(position, segment, track, track\_len)

Körs när en givare passerats. Gör en bedömning om en givare (eller flera) har
missats genom att kontrollera vilken givare som är närmast den nuvarande
uppskattade position och kompenserar om en givare bedöms ha missats.

clamp(n, m, M)

En hjälpfunktion som returnerar n om $m < n < M$, annars m om $n < m$, annars M
om $n > M$.

detect\_missed(position, segment, track, track\_len)

Returnerar true om position ligger utanför det nuvarande segmentet.

do\_boot(car, boot)

Anropas en gång per programcykel i den så kallade boostrap-fasen. Se ANNAN DEL
AV TEXTEN för information.

do\_car(car, t, displa\_data, boot)

Anropas en gång per programcykel. Se ANNAN DEL AV TEXTEN och EN ANNAN DEL
AV TEXTEN för information om hur en programcykel ser ut och NÅGOT MER.

do\_gov(car)

Anropas varje gång en givare passerats. Vid målgivaren jämförs referenstiden och
den förra varvtiden och car.constant anpassas efter differensen mellan dem. Om
differensen är högre ändras car.constant mer, och vice versa om differensen är
låg. Vid givare 5 och 8 jämförs referenstiden och en uppskattning av hur lång
tid det nuvarande varvet troligen kommer ta. Se EN ANNAN DEL AV TEXTEN för
mer information.

fit\_percents(percents, lap\_time, seg\_times)

Anropas vid varje nytt varv. Räknar ut den procentuella tiden varje segment tog
det förra varvet och sparar medelvärdet mellan den förra procentsatsen och den
nya, uträknade procentsatsen. Procentsatsen normeras sedan så summan är 1
(100%).

format\_seg\_times(car)

Anropas när körningen avslutas. Returnerar den genomsnittliga tiden för varje
segment.

get\_aprox\_v(cur\_seg, car)

Anropas varje programcykel. Uppskattar bilens nuvarande hastighet genom att
dividera den senast uppmätta segmentstiden med segmentets längd.

get\_new\_u(new\_v, seg\_constant

FLYTTA BERÄKNINGEN TILL DO\_CAR, BEHÖVER INTE VARA EN EGEN FUNKTION

get\_new\_v(position, list)

Anropas varje programcykel. Söker igenom bankartan och returnerar värdet v som
matchar position.

get\_position(aprox\_v, prev\_p, delta\_t)

Anropas varje programcykel. Räknar ut hur långt bilen rört sig sedan senaste
programcykeln.

get\_seg\_constant(position, lap\_constants, track, track\_len)

TA BORT

get\_time\_as\_string(millis)

Omvandlar en mängd millisekunder till formatet "mm:ss.s". Till exempel omvandlas 1250
ms till "00:01.3" och 11240 till "00:11.2".

main.m

Huvudskriptet som startar hela systemet.

\subsection{Display}

bar\_graph(direction, no, x1, x2, y1, y2, start\_value, end\_value, type, pattern):

Skapar ett stapeldiagram med ett hörn i (*x1*, *y1*) och ett diagonellt
hörn i (*x2*, *y2*). *direction* är en av 'O', 'U', 'L' och 'R' och
bestämmer åt vilket håll "upp" är på stapeln. 'O' står för upp ('oben'
på tyska), 'U' står för ner ('unter' på tyska), 'L' står för vänster
('links') och 'R' står för höger ('rechts'). Värdet stapeldiagrammet ska
visa specifieras med *update\_bar\_graph*. *start\_value* och
*end\_value* bestämmer vad som ska vara noll- respektive maxvärde för
stapeldiagrammet. *no* är stapeldiagrammets nummer och behöver
specifieras när stapeldiagrammets värde ska uppdateras. *type* sätts
till 0 för en enkel stapel och 1 för en stapel inuti en ram.

box(x1, y1, x2, y2, n1)

Ritar en rektangel med diagonella hörn i (*x1*, *y1*) och (*x2*, *y2*)
och mönster-nummer *n1*.

clear\_display()

Rensa displayen.

continue\_line(x2, y2)

Fortsätt en linje från den senast specifierade linjens slut till (*x2*,
*y2*).

delete\_area(x1, y1, x2, y2)

Ta bort (släck) alla pixlar i det rektangulära området mellan (*x1*,
*y1*) och (*x2*, *y2*).

draw\_line(x1, y1, x2, y2)

Rita en linje mellan (*x1*, *y1*) och (*x2*, *y2*).

draw rectangle(x1, y1, x2, y2)

Rita en rektangel (ej ifylld) mellan (*x1*, *y1*) och (*x2*, *y2*).

fill\_area(x1, y1, x2, y2)

Tänd alla pixlar i det rektangulära området mellan (*x1*, *y1*) och
(*x2*, *y2*).

fill\_area\_with\_pattern(x1, y1, x2, y2, n1)

Fyll det rektangulära området mellan (*x1*, *y1*) och (*x2*, *y2*) med
mönster *n1*.

fill\_display()

Tänd alla pixlar på displayen.

flashing\_area(x1, y1, x2, y2)

Fyll det rektangulära området mellan (*x1*, *y1*) och (*x2*, *y2*) med
blinkande pixlar. Blinkintervallet kan sättas med *set\_flashing\_time*.

flashing\_area\_with\_pattern(x1, y1, x2, y2)

Fyll det rektangulära området mellan (*x1*, *y1*) och (*x2*, *y2*) med
blinkande pixlar i ett mönster. Blinkintervallet kan sättas med
*set\_flashing\_time*.

invert\_area(x1, y1, x2, y2)

Tänd alla släckta pixlar och släck alla tända pixlar i det rektangulära
området mellan (*x1*, *y1*) och (*x2*, *y2*).

invert\_display()

Tänd alla släcka pixlar och släck alla tända pixlar på hela displayen.

key(x1, y1, x2, y2, down\_code, up\_code, just, text)

Skapa en tryckbar knapp (till skillnad från en omkopplare, se
*toggle(...)*) med diagonella hörn i (*x1*, *y1*) och (*x2*, *y2*) och
texten *text*. Hur texten justeras beror på *just* där 'R' gör texten
högerjusterad ('right'), 'C' gör texten centerjusterad och 'L' gör
texten vänsterjusterad ('left'). Om knappen trycks ned läggs
*down\_code* i displayens interna minne och om knappen släpps läggs
*up\_code* i displayens interna minne.

point(x1, y1)

Rita en punkt i (*x1*, *y1*). Punktens storlek kan anpassas med
*set\_point\_size*.

put\_text(x, y, justification, text)

Skriv ut texten *text* i (*x*, *y*). Hur texten justeras beror på
*justification* där 'R' gör texten högerjusterad ('right'), 'C' gör
texten centerjusterad och 'L' gör texten vänsterjusterad ('left'). Om
*justification* är 'R' bestämmer *x* och *y* textens övre högra
koordinat, om *justification* är 'C' bestämmer *x* och *y* textens
mittre koordinat och om *justification* är 'L' bestämmer *x* och *y*
textens övre vänstra koordinat.

redraw\_bar\_graph(num)

Tvinga stapeldiagram *num* att ritas om.

remove\_flashing\_area(x1, y1, x2, y2)

Ta bort blinkade pixlar i det rektangulära området mellan (*x1*, *y1*)
och (*x2*, *y2*).

request\_bar\_graph\_value(num)

Lägg nuvarande värdet för stapeldiagram *num* i displayens interna
minne.

restore\_display\_from\_clipboard()

Flytta innehållet från displayens urklipp till displayen.

restore\_display\_from\_clipboard\_to\_point(x1, y1)

Flytta innehållet från displayens urklipp till displayen med övre
vänstra hörn i (*x1*, *y1*). Spara ett område med
\_save\_area\_to\_clipboard(...).

save\_area\_to\_clipboard(x1, y1, x2, y2)

Kopiera innehållet i den rektangel mellan (*x1*, *y1*) och (*x2*, *y2*)
till displayens urklipp. Återställ med
*restore\_display\_from\_clipboard\_to\_point(...)*.

save\_display\_to\_clipboard()

Kopiera displayens nuvarande innehåll till displayens urklipp. Återställ
med *restore\_display\_from\_clipboard()*.

set\_display\_visible(visible)

Sätt om displayen ska vara synlig (*visible* = true) eller om displayen
ska vara osynlig (*visible* = false). Att displayen är osynlig innebär
att innehållet inte syns men finns kvar i bakgrunden och kan visas igen
om *set\_display\_visible(true)* skickas.

set\_drawing\_mode(n1)

Sätt displayens ritläge. *n1* = 1 innebär att pixlar slås på eller av
(som vanligt) enligt kommandot som skickas, *n1* = 2 innebär att pixlar
enbart slås av (som ett suddgummi) och *n1* = 3 innebär att pixlar
inverteras (släckta pixlar slås på och tända pixlar stängs av)

set\_flashing\_time(n1)

Sätt intervallet blinkande objekt blinkar i. *n1* är ett intervall i
tiondelar av en sekund mellan 0,1 sekunder och 1,5 sekunder.

set\_line\_pattern(n1)

Sätt mönstret linjer ritas ut med.

set\_point\_size(n1, n2)

Sätt storleken på punkter och linjer som ritas ut. *n1* är storleken i
x-led (mellan 1 och 15 pixlar) och *n2* är storleken i y-led (mellan 1
och 15 pixlar).

set\_text\_flashing(n1)

Sätt om ny text som skrivs ut ska blinka eller inte. *n1* = 1 slår på
blinkande och *n1* = 2 stänger av blinkande.

set\_text\_font(font\_num)

Sätt typsnittet på ny text som skrivs ut. Se *REF* för information om de
olika typsnitten.

set\_text\_zoom(x\_scale, y\_scale)

Sätt skalfaktorn för ny text som skrivs ut. *x\_scale* är skalfaktorn i
x-led (mellan x1 och x8) och *y\_scale* är skalfaktorn i y-led (mellan
x1 och x8).

set\_touch\_sound\_response(state)

Sätt om displayen ska göra ljud när knappar trycks ned. *state* = 1 slår
på ljudet och *state* = 0 stänger av ljudet.

toggle(x1, y1, x2, y2, down\_code, up\_code, just, text)

Skapa en tryckbar omkopplare (till skillnad från en knapp, se
*key(...)*) med diagonella hörn i (*x1*, *y1*) och (*x2*, *y2*) och
texten *text*. Hur texten justeras beror på *just* där 'R' gör texten
högerjusterad ('right'), 'C' gör texten centerjusterad och 'L' gör
texten vänsterjusterad ('left'). Om knappen aktiveras läggs *down\_code*
i displayens interna minne och om knappen avaktiveras läggs *up\_code* i
displayens interna minne.

update\_bar\_graph(num, val)

Skicka värdet *val* till stapeldiagram *num*.

\section{Material}

Projektgruppen har av beställaren tillhandahållits ett lab med följande utrustning:

\begin{itemize}
	\item En bilbana utrustad med givare vars funktion är att detektera passerade bilar.
	\item Två datorer
	\item En display med touchfunktionallitet. 
	\item Ett antal bilar 
\end{itemize}

\section{Sluttest}

\section{Kravbeskrivning}

Krav 1. Systemet är helt skrivet i matlab.

Krav 2. Systemet kan startas oavsett bil på banan.. 

Krav 3. Systemet klarar av att missa givare. 

Krav 4. När ett varv har körts så uppdaterar displayen vilket varv som nyss
genomfördes samt varvtiden. 

Krav 5. Under programmets gång visas det nuvarande gaspådraget. 

Krav 6. Efter att programmet avslutats visas information på displyen.

Krav 7. Systemet kan köras oavsett vilken bil som placeras på banan. 

Krav 8. Programmet hanterar driftsfall genom att kompensera en större eller
mindre styrsignal. 

Krav 9. Om systemet inte får en nt insignal i form av en passerad givare inom
tio sekunder pausas systemet och användaren får frågan om denne vill fortsätta
eller avsluta. 

Krav 10. Användaren har alternativet att köra en eller båda banorna samt hur
banorna ska köras, autonomnt eller manuellt. Det manuella alternativet uppfyller
inte krav 8 på beslut av beställaren. 

Krav 11. Kravet struket från beslut av beställare. 

Krav 12. Tillsammans med frågan om bana ett eller två ska köras frågar
programmet systemet om banan ska köras manuellt eller autonomt. 

Krav 13. För att starta programmet krävs att man kan öppna matlab och starta
programmet. Därefter kan användaren starta med hjälp av displayen.  
 
Krav 14. När systemet startar frågar programmet användaren vilka banor som skall
köras samt vilken referenstid de ska ha. 

Krav 15. Systemet ställer de frågor till användaren via touch displayen.

Krav 16. Enligt de två givna testerna åkte bilarna inte av banan.

Krav 17. När programmet startas frågar programmet användaren vilken referenstid
som ska strävas efter, detta görs i ett intervall ]12,15[ med justeringar på 0,5
sekunder upp eller ner. 

Krav 18. Enligt de två visade körningarna stannade inte bilarna under något
tillfälle. 

Krav 19. 

Krav 20. De två testkörningarna resulterade i en standardavvikelse på 0,22
respektive 0,24. Kravet är delvis uppnått. 

Krav 21. De två testkörningarna resulterade i att bilarna överskred gränsen på
0.5 ett fåtal gånger, kravet delvsi uppnått. 

Krav 22. Kraven var delvis uppfyllda efter 5 varv. 

Krav 23. Kravet struket av beställaren. 

Krav 24. Resultaten sparades och delades med beställaren via email.  

Krav 25. Efter avslutad körning visas statistik i form av de plottar som önskas
i kravspecifikationen. 

Krav 26. Efter avslutad körning sparas alla data i en fil.  

Krav 27. Längre upp i dokumentet beskrivs hur tidtagningen gick till och hur den
validerades.

Krav 28. 

Krav 29. Deltagande i projektet har angett den tid de jobbat efter varje moment. 

Krav 30. Handledaren har inte bidragit med hjälp i mer än 25h.

Krav 31. Efter att programmet avslutas visas den cykel som tog längst tid, då
den inte passerar 0,1 sekunder. 

Krav 32. Efter två veckor av projektet godkänndes projektplanen. 

Krav 33. Under projektvecka fyra godkändes designspecifikationen av beställaren. 

Krav 34. Under projektvecka fem redovisade projektgruppen kraven 2, 4, 31 samt 25. 

Krav 35. Under projektvecka sju redovisade projektgruppen kraven 3, 5, 10, 17
samt 18. Även de krav som uppfylldes under bp.4a visades. 

Krav 36. Under projektvecka nio redovisade projektgruppen samtliga Lrav som
uppfyllts tidigare samt alla krav i avsnitt 3.2.

Krav 37. Programvaran levererades under projektvecka 10. 

Krav 38. Den tekniska dokumentationen levererades under projektvecka 10. 

Krav 39. Under projektvecka tio hölls en slutleverans där gruppen visade upp
samtliga krav och höll en presentation över vad hur arbetet har sett ut. 

Krav 40. Inför varje beslutspunkt har önskade dokument varit beställaren
tillhandahållna innan 09:00 arbetsdagen innan mötet. 

Krav 41. Projektledaren har delat tidsrapportering samt eventuella
mötesprotokoll vid rätt tid de flesta av projektveckorna, kravet är därför
delvis uppnått.

Krav 42. Alla dokument samt all programvara har samlats i gitlab minst en gång i
veckan sedan projektvecka 2. 

Krav 43. Projektplan, designspecifikation, mötesprotokoll, teknisk
dokumentation, testprotokoll samt efterstudie har gjorts. 

Krav 44. Dokument samt programvaran har bearbetats samt lagrats på
http://gitlab.ida.liu.se/.  

Krav 45. Alla dokument framtagna av projektgruppen har levererats i pdf-format. 

Krav 46. Alla dokument skrivna av projektgruppen är är skrivet på formell
korrekt svenska.

Krav 47. Dokumentationen innehåller, 

Krav 48. Programmet är uppdelat i funktioner. 

Krav 49. Projektgruppen har samtlats på mint ett möte i veckan där alla
medlemmar har närvarat. Handledaren har inte närvarat vilket resulterar i ett
delvis uppnått krav. 

\end{document}

